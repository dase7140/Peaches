from __future__ import print_function
import cv2
import numpy as np
import serial
import time
import threading
import sys
from queue import Queue, Empty
from picamera2 import Picamera2
import pixy
from ctypes import *
from pixy import *


############################
# Serial Communication Setup
############################

port = "/dev/ttyACM0"      # Arduino port on Raspberry Pi
ser = serial.Serial(port, 115200, timeout=1) # establish serial connection
time.sleep(2)               # wait for the serial connection to initialize
ser.reset_input_buffer()    # clear input buffer to start fresh
ser.reset_output_buffer()   # clear output buffer to start fresh

# Thread control and state variables
serial_reader_running = False
estop_triggered = False
serial_thread = None
user_stop_requested = False
stdin_thread = None

# Message queues for routing serial data
ack_queue = Queue()  # For ACK messages
ir_queue = Queue()   # For IR sensor data

def serial_reader():
    """
    Continuously reads incoming serial messages from Arduino.
    Routes messages to appropriate queues for other functions to consume.
    
    Message routing:
    - ESTOP: Sets global flag immediately
    - ACK:*: Routed to ack_queue for pi_2_ard()
    - IR:*: Routed to ir_queue for read_ir_sensors()
    - Other: Printed as general Arduino output
    """
    global serial_reader_running, estop_triggered
    
    print("[Serial Reader] Thread started")
    
    while serial_reader_running:
        try:
            if ser.in_waiting > 0:
                line = ser.readline().decode('utf-8', errors='replace').strip()
                
                if line:
                    # Handle ESTOP message - immediate action
                    if line == "ESTOP":
                        estop_triggered = True
                        print("[Arduino] EMERGENCY STOP TRIGGERED")
                    
                    # Route ACK messages to ack_queue
                    elif line.startswith("ACK:"):
                        ack_queue.put(line)
                    
                    # Route IR data to ir_queue
                    elif line.startswith("IR:"):
                        ir_queue.put(line)
                    
                    # Print other messages
                    else:
                        print(f"[Arduino] {line}")
            
            # Small delay to prevent busy waiting
            time.sleep(0.01)
            
        except Exception as e:
            print(f"[Serial Reader] Error: {e}")
            time.sleep(0.1)
    
    print("[Serial Reader] Thread stopped")



def start_serial_reader():
    """
    Starts the serial reader thread.
    Call this at the beginning of your main program.
    """
    global serial_reader_running, serial_thread
    
    if serial_thread is not None and serial_thread.is_alive():
        print("[Serial Reader] Thread already running")
        return
    
    serial_reader_running = True
    serial_thread = threading.Thread(target=serial_reader, daemon=True)
    serial_thread.start()
    print("[Serial Reader] Thread started successfully")



def stop_serial_reader():
    """
    Stops the serial reader thread.
    Call this when shutting down the program.
    """
    global serial_reader_running, serial_thread
    
    if serial_thread is None or not serial_thread.is_alive():
        print("[Serial Reader] Thread not running")
        return
    
    print("[Serial Reader] Stopping thread...")
    serial_reader_running = False
    serial_thread.join(timeout=2.0)  # Wait up to 2 seconds for thread to finish
    
    if serial_thread.is_alive():
        print("[Serial Reader] Warning: Thread did not stop cleanly")
    else:
        print("[Serial Reader] Thread stopped successfully")



def User_Input():
    """
    Monitors stdin for user commands in a separate thread.
    Specifically watches for 'STOP' command to emergency stop the robot.
    """
    global user_stop_requested
    
    print("[User Input] Thread started - Type 'STOP' at any time to emergency stop")
    
    while not user_stop_requested:
        try:
            user_input = input().strip().upper()
            if user_input == "STOP":
                user_stop_requested = True
                print("\n[USER STOP] Emergency stop requested!")
                break
        except (EOFError, KeyboardInterrupt):
            break
        except Exception as e:
            print(f"[User Input] Error: {e}")
            time.sleep(0.1)
    
    print("[User Input] Thread stopped")



def start_User_Input():
    """
    Starts the stdin monitor thread.
    Allows user to type 'STOP' to emergency stop the robot.
    """
    global user_stop_requested, stdin_thread
    
    if stdin_thread is not None and stdin_thread.is_alive():
        print("[User Input] Thread already running")
        return
    
    user_stop_requested = False
    stdin_thread = threading.Thread(target=User_Input, daemon=True)
    stdin_thread.start()



def stop_User_Input():
    """
    Signals the stdin monitor thread to stop.
    """
    global user_stop_requested, stdin_thread
    
    if stdin_thread is None or not stdin_thread.is_alive():
        return
    
    user_stop_requested = True


# Send command from Pi to Arduino with ACK waiting and retry logic
def pi_2_ard(command, max_retries=3, timeout=1.0):
    """
    Sends a command to Arduino and waits for acknowledgment from ack_queue.
    Retries if no ACK is received within timeout period.
    
    Args:
        command: str - Command to send to Arduino
        max_retries: int - Maximum number of retry attempts (default: 3)
        timeout: float - Seconds to wait for ACK before retrying (default: 1.0)
        
    Returns:
        bool - True if ACK received, False if all retries failed
    """
    for attempt in range(max_retries):
        try:
            # Clear any stale ACKs from queue
            stale_count = 0
            while not ack_queue.empty():
                try:
                    stale_ack = ack_queue.get_nowait()
                    stale_count += 1
                except Empty:
                    break
            
            if stale_count > 0:
                print(f"[Comm] Cleared {stale_count} stale ACK(s) from queue")
            
            # Brief delay to ensure Arduino is ready for next command
            time.sleep(0.05)
            
            # Send command to Arduino
            ser.write((command + '\n').encode('utf-8'))
            ser.flush()
            
            # Wait for ACK response from queue
            expected_ack = f"ACK:{command}"
            
            # Keep checking queue until we get the right ACK or timeout
            start_time = time.time()
            while (time.time() - start_time) < timeout:
                try:
                    # Wait for message from queue with shorter timeout for polling
                    ack_msg = ack_queue.get(timeout=0.1)
                    
                    # Check if this is the expected ACK
                    if ack_msg == expected_ack:
                        if attempt > 0:
                            print(f"[Comm] Command '{command}' acknowledged (attempt {attempt + 1})")
                        return True
                    else:
                        # Wrong ACK - likely from previous command, keep waiting
                        print(f"[Comm] Ignoring late ACK: {ack_msg} (waiting for {expected_ack})")
                        
                except Empty:
                    # No message yet, keep waiting
                    continue
            
            # Timeout reached - no correct ACK received
            if attempt < max_retries - 1:
                print(f"[Comm] No ACK for '{command}' (attempt {attempt + 1}/{max_retries}), retrying...")
            else:
                print(f"[Comm] FAILED: No ACK for '{command}' after {max_retries} attempts")
        
        except Exception as e:
            print(f"[Comm] Error sending command '{command}': {e}")
            if attempt < max_retries - 1:
                time.sleep(0.1)  # Brief delay before retry
    
    return False  # All retries failed


COLOR_MAP = {
    "red": 1,
    "green": 2,
    "blue": 3,
    "yellow": 4,
    "purple": 5,    # GRAVEL
    "orange": 6,    # RAMP
    "l_blue": 7     # OTHER FLAG COLOR
}

#Pixy Init:
#1 = red, 2 = green 3 = blue 4= yellow 5 = purple (GRAVEL)  6 = pink (RAMP)
centerX = 157
deadband = 30
target_Signature = COLOR_MAP["red"]  # change for dice designation, red die for now
dice_sig = target_Signature
lastTargetDirection = 0
lostTargetTimer = 0
searchTimeout = 3000

pixy.init()
pixy.change_prog("color_connected_components")


#class to pull from 
class Blocks(Structure):
    _fields_ = [
        ("m_signature", c_uint),
        ("m_x", c_uint),
        ("m_y", c_uint),
        ("m_width", c_uint),
        ("m_height", c_uint),
        ("m_angle", c_uint),
        ("m_index", c_uint),
        ("m_age", c_uint),
    ]

blocks = BlockArray(100)
frame = 0
onGravel = False
onBridge = False

def seeColor(sig, count):
    for i in range(count):
        if blocks[i].m_signature == sig:
            return True
    return False

def getTargetX(sig, count):
    for i in range(count):
        if blocks[i].m_signature == sig:
            return blocks[i].m_x
    return -1

def getColor(index):
    return blocks[index].m_signature

def Pixicam():  # FOR DICE
    """
    Queries Pixy camera for color blocks matching target signature.
    Ignores targets in the TOP HALF of the frame.
    
    Returns:
        bool - True if target detected in bottom half, False otherwise
    """
    try:
        count = pixy.ccc_get_blocks(100, blocks)
        now = int(round(time.time() * 1000))

        if count > 0:
            for i in range(count):

                # Only consider blocks with the target signature
                if blocks[i].m_signature == target_Signature:

                    x = blocks[i].m_x
                    y = blocks[i].m_y

                    # IGNORE dice in top half of screen
                    if y < 104:   # top half
                        continue  # skip it

                    # valid block found in bottom half
                    return True

            # no valid dice detected in bottom half
            return False

        else:
            return False

    except Exception:
        return False


def lookForFlags():
    """
    looks for the signatures associated with the three flags on the course, checks if within distance threshold of them
    returns which of the three flags are visible at any time

    wrapped in function that determines which flag is present, updates booleans and updates relevant commands (raises tray, etc)

    returns
        success: bool - returns true if the camera successfully read, otherwise all arguments are false
        first_flag: bool -(before gravel)
        second_flag: bool -  (after gravel)
        third_flag: bool - (after bridge)
    """
    try:
        count = pixy.ccc_get_blocks(100, blocks)
        if count == 0:
            # no blocks detected
            return True, False, False, False

        # Map signatures to booleans
        seen = {sig: seeColor(sig, count) for sig in COLOR_MAP.values()}

        # Example logic (update to match your course definitions):
        first_flag = seen.get(COLOR_MAP["orange"], False) and seen.get(COLOR_MAP["purple"], False)
        second_flag = seen.get(COLOR_MAP["orange"], False) and seen.get(COLOR_MAP["l_blue"], False)
        third_flag = seen.get(COLOR_MAP["purple"], False) and seen.get(COLOR_MAP["blue"], False)

        return True, first_flag, second_flag, third_flag
    except Exception as e:
        print("[PIXy ERROR] lookForFlags exception:", e)
        return False, False, False, False

def pixySetFlags():
    """
    When called, checks the current set of pixy blocks to determine if we have seen the colors relevent to the flags
    on the course

    If so, makes relevent variable adjustments:
    See first flag: raises collection tray, bool blocks any further commands to lower it, increases speeds in all navigation commands
    See second flag: removes gravel boolean and sets bridge one. This changes speeds and may initiate a bridge animation
    See third flag: reset first two flags

    returns 
        nothing

    """
    #print("Setting pixy flags:")

    global onGravel, onBridge, BASE_SPEED, TURN_SPEED, VEER_SPEED 
    success, first_flag, second_flag, third_flag = lookForFlags()
    if not success:
        return

    if first_flag and not onGravel:
        print("[PIXY FLAGS] Entering gravel mode")
        onGravel = True
        onBridge = False
        BASE_SPEED = 4
        TURN_SPEED = 4
        VEER_SPEED = 5

    elif second_flag and not onBridge:
        print("[PIXY FLAGS] Entering bridge mode")
        onBridge = True
        onGravel = False
        BASE_SPEED = 2
        TURN_SPEED = 2
        VEER_SPEED = 3

    elif third_flag: #SLOW motors to pass ramp
        if onGravel or onBridge:
            print("[PIXY FLAGS] Leaving special areas")
        onBridge = False
        onGravel = False
        BASE_SPEED = 2
        TURN_SPEED = 2
        VEER_SPEED = 3

def mainLoop(): #logic for dice vs flag prioiritization
   
    while True: 
        pixySetFlags()  # Check and set flags first
        diceSeen = Pixicam()
        if diceSeen:
            print("Dice seen")

if __name__ == '__main__':
    mainLoop()
    time.sleep(0.02)
